
#####################################################################
# RAPPORT lignes de commandes
#####################################################################

# Tableau RTUPB (post-opératoire) 
# -------------------------------- 

# ******************************************
# PAM
# ******************************************
duplicated(postRTUPB)
sil<-numeric(20)
for(k in 2:20) { sil[[k]]<-cluster::pam(postRTUPB,k)$silinfo$avg.width }
plot(2:20, sil[2:20], main = "postRTUPB clustering using PAM", xlab = "#clusters", ylab="sil.avg.width", sub="from 2 to 20")
abline(v = 2, col = "red")
abline(v = 3, col = "red")
abline(v = 13, col = "blue")

# k=2 - vérification 
plot(cluster::pam(postRTUPB, 2))
duplicated(postRTUPB[c(11,28,33),])
duplicated(rawRTUPB[c(11,28,33),])
#
plot(cluster::pam(postRTUPB, 3))
plot(cluster::pam(postRTUPB, 13))
respam13<-cluster::pam(postRTUPB, 13)

# ******************************************
# CAH
# ******************************************
rescah<-hclust(dist(postRTUPB), method="ward")
plot(hclust(dist(postRTUPB)), hang=-1)
rect.hclust(rescah, 13)

# ******************************************
# Profils de guérison
# ******************************************
IPSSmedoids<-NULL
QoLmedoids<-NULL
QMaxmedoids<-NULL
for (k in 1:13) { 
  IPSSmedoids<-rbind(IPSSmedoids, postRTUPB[respam13$medoids[k],c(1,4,7,10,13,16,19)])
  QoLmedoids<-rbind(QoLmedoids, postRTUPB[respam13$medoids[k],c(2,5,8,11,14,17,20)])
  QMaxmedoids<-rbind(QMaxmedoids, postRTUPB[respam13$medoids[k],c(3,6,9,12,15,18,21)])
}
par(mfrow=c(1,3))
for (m in 1:13) {
 plot( x <- c(1:7), y <- IPSSmedoids[m, x], type = "l", col= m, xaxt = "n", xlab="# months", main = paste("IPSS for RTUPB profile #", as.character(m)))
 axis(1, at=1:7, labels=c(1,3,6,9,12,15,18))
 plot( x <- c(1:7), y <- QoLmedoids[m, x], type = "l", col= m, xaxt = "n", xlab="# months",, main = paste("QoL for RTUPB profile #", as.character(m)))
 axis(1, at=1:7, labels=c(1,3,6,9,12,15,18))
 plot( x <- c(1:7), y <- QMaxmedoids[m, x], type = "l", col= m, xaxt = "n", xlab="# months",, main = paste("QMax for RTUPB profile #", as.character(m))) 
 axis(1, at=1:7, labels=c(1,3,6,9,12,15,18))
}

# Tableau VBPPS (post-opératoire) 
# -------------------------------- 

# ******************************************
# PAM
# ******************************************
sil<-numeric(20)
for(k in 2:20) { sil[[k]]<-cluster::pam(postVPPBS,k)$silinfo$avg.width }
plot(2:20, sil[2:20], main = "postVPPBS clustering using PAM", xlab = "#clusters", ylab="sil.avg.width", sub="from 2 to 20")
abline(v = 4, col = "red")
abline(v = 12, col = "blue")

plot(cluster::pam(postVPPBS, 4))
plot(cluster::pam(postVPPBS, 12))
respam12 = cluster::pam(postVPPBS, 12)

# ******************************************
# CAH
# ******************************************
rescah<-hclust(dist(postVPPBS), method="ward")
plot(hclust(dist(postVPPBS)), hang=-1)
rect.hclust(rescah, 12)

# ******************************************
# Profils de guérison
# ******************************************
IPSSmedoids<-NULL
QoLmedoids<-NULL
QMaxmedoids<-NULL
for (k in 1:12) { 
  IPSSmedoids<-rbind(IPSSmedoids, VBPPSpost[respam10$medoids[k],c(1,4,7,10,13,16,19)])
  QoLmedoids<-rbind(QoLmedoids, VBPPSpost[respam10$medoids[k],c(2,5,8,11,14,17,20)])
  QMaxmedoids<-rbind(QMaxmedoids, VBPPSpost[respam10$medoids[k],c(3,6,9,12,15,18,21)])
}
par(mfrow=c(1,3))
for (m in 1:12) {
 plot( x <- c(1:7), y <- IPSSmedoids[m, x], type = "l", col= m, xaxt = "n", xlab="# months", main = paste("IPSS for VPPBS profile #", as.character(m)))
 axis(1, at=1:7, labels=c(1,3,6,9,12,15,18))
 plot( x <- c(1:7), y <- QoLmedoids[m, x], type = "l", col= m, xaxt = "n", xlab="# months", main = paste("QoL for VPPBS profile #", as.character(m)))
 axis(1, at=1:7, labels=c(1,3,6,9,12,15,18))
 plot( x <- c(1:7), y <- QMaxmedoids[m, x], type = "l", col= m, xaxt = "n", xlab="# months", main = paste("QMax for VPPBS profile #", as.character(m))) 
 axis(1, at=1:7, labels=c(1,3,6,9,12,15,18))
}


# Tableau VAPOR (post-opératoire) 
# -------------------------------- 
library(readxl)
rawVAPOR <- read_excel("VAPOR.xlsx", col_types = c("skip", 
    "numeric", "logical", "numeric", "logical", 
    "numeric", "numeric", "numeric", "numeric", 
    "numeric", "numeric", "numeric", "numeric", 
    "logical", "numeric", "logical", "numeric", 
    "numeric", "numeric", "logical", "logical", 
    "numeric", "numeric", "numeric", "numeric", 
    "numeric", "numeric", "numeric", "numeric", 
    "numeric", "numeric", "numeric", "numeric", 
    "numeric", "numeric", "numeric", "numeric", 
    "numeric", "numeric", "numeric", "numeric", 
    "numeric"), skip = 1)
View(rawVAPOR)
preVAPOR<-rawVAPOR[,c(1:20)]
preVAPOR_clean<-rawVAPOR[!duplicated(rawVAPOR),-c(10,11,12,14)]

# ******************************************
# PAM
# ******************************************
sil<-numeric(20)
for(k in 2:20) { sil[[k]]<-cluster::pam(preVAPOR_clean,k)$silinfo$avg.width }
plot(2:20, sil[2:20], main = "preVAPOR clustering using PAM", xlab = "#clusters", ylab="sil.avg.width", sub="from 2 to 20")

# ******************************************
# Classification supervisée RTUPB-VPPBS
# ******************************************
# ******************************************
# IPSS
# ******************************************
# ******************************************
# QoL
# ******************************************
# ******************************************
# Qmax
# ******************************************
# ******************************************
# Classification non-supervisée VAPOR
# ******************************************
# ******************************************
# IPSS
# ******************************************
fitIPSS<-rpart::rpart(IPSS__4 ~ ., data = rawVAPOR[,c(01:20,33)])
plot(fitIPSS, main="VAPOR: prédiction IPSS à 12 mois")
text(fitIPSS,use.n=TRUE)
# ******************************************
# QoL
# ******************************************
fitQoL<-rpart::rpart(QoL__4 ~ ., data = rawVAPOR[,c(01:20,34)])
plot(fitQoL, main="VAPOR: prédiction QoL à 12 mois")
text(fitQoL,use.n=TRUE)
# ******************************************
# Qmax
# ******************************************
fitQmax<-rpart::rpart(`Qmax (ml/s)__3` ~ ., data = rawVAPOR[,c(01:20,35)])
plot(fitQmax, main="VAPOR: prédiction Qmax à 12 mois")
text(fitQmax,use.n=TRUE)
# **********************************
# Classification supervisée RTUPB
# **********************************
library(rpart)
library(rpart.plot)
library(corrplot)
library(rattle)
setIPSS<-subset(rawRTUPBSVPPBS[, c(1:21,34)],"technique"="RTUPB")[,-c(1,11,14,15,16,21)]
# 80% of rows -> training set
ns<-floor(0.80*nrow(setIPSS))
# shuffle rows
shuffle<-setIPSS[sample(nrow(setIPSS)),]
trainIPSS<-shuffle[1:ns,]
testIPSS<-shuffle[-c(1:ns),]
dt<-rpart(IPSS__4 ~. , data = trainIPSS, method="class")
plot(dt, margin = .1, main="Arbre de Régression pour IPSS à 12 mois sur RTUPB")
text(dt, use.n = TRUE)
rpart.plot::rpart.plot(dt,type=0, extra=4, main="Arbre de Régression pour IPSS à 12 mois sur RTUPB")
summary(dt)
predict(dt, testIPSS)
resIPSS_RTUPB<-predict(dt, testIPSS)
corrplot::corrplot(t(resIPSS_RTUPB),is.corr=TRUE, cl.pos = 'n', title="Prédiction IPSS pour échantillon de test RTUPB")
##################
setQoL<-subset(rawRTUPBSVPPBS[, c(1:21,35)],"technique"="RTUPB")[,-c(1,11,14,15,16,21)]
shuffle<-setQoL[sample(nrow(setQoL)),]
trainQoL<-shuffle[1:ns,]
testQoL<-shuffle[-c(1:ns),]
dt<-rpart(QoL__4 ~. , data = trainQoL, method="class")
plot(dt, margin = .1, main="Arbre de Régression pour QoL à 12 mois sur RTUPB")
text(dt, use.n = TRUE)
rpart.plot::rpart.plot(dt,type=0, extra=4, main="Arbre de Régression pour QoL à 12 mois sur RTUPB")
summary(dt)
resQoL_RTUPB<-predict(dt, testQoL)
corrplot::corrplot(t(resQoL_RTUPB),is.corr=TRUE, cl.pos = 'n', title="Prédiction QoL pour échantillon de test RTUPB")
barplot( testQoL$QoL__4, names.arg = rownames(testQoL), main='Vérification QoL pour  échantillon de test RTUPB' )
##################
setQmax<-subset(rawRTUPBSVPPBS[, c(1:21,36)],"technique"="RTUPB")[,-c(1,11,14,15,16,21)]
shuffle<-setQmax[sample(nrow(setQmax)),]
trainQmax<-shuffle[1:ns,]
testQmax<-shuffle[-c(1:ns),]
dt<-rpart(`Qmax (ml/s)__3` ~. , data = trainQmax)
plot(dt, margin = .1, main="Arbre de Régression pour Qmax à 12 mois sur RTUPB")
text(dt, use.n = TRUE)
resQmax_RTUPB<-predict(dt, testQmax)
barplot( rbind(resQmax_RTUPB, testQmax$`Qmax (ml/s)__3`), beside=TRUE, names.arg = rownames(testQmax), main='Vérification Qmax pour  échantillon de test RTUPB' )
# **********************************
# Classification supervisée VPPBS
# **********************************
library(rpart)
setIPSS<-subset(rawRTUPBSVPPBS[, c(1:21,34)],"technique"="VPPBS")[,-c(1,5,11,14,15,16,18,20,21)]
# 80% of rows -> training set
ns<-floor(0.80*nrow(setIPSS))
# shuffle rows
shuffle<-setIPSS[sample(nrow(setIPSS)),]
trainIPSS<-shuffle[1:ns,]
testIPSS<-shuffle[-c(1:ns),]
dt<-rpart(IPSS__4 ~. , data = trainIPSS, method="class")
plot(dt, margin = .1, main="Arbre de Régression pour IPSS à 12 mois sur VPPBS")
text(dt, use.n = TRUE)
rpart.plot::rpart.plot(dt,type=0, extra=4, main="Arbre de Régression pour IPSS à 12 mois sur VPPBS")
summary(dt)
resIPSS_VPPBS<-predict(dt, testIPSS)
corrplot::corrplot(t(resIPSS_VPPBS),is.corr=TRUE, cl.pos = 'n', title="Prédiction IPSS pour échantillon de test VPPBS")
##################
setQoL<-subset(rawRTUPBSVPPBS[, c(1:21,35)],"technique"="VPPBS")[,-c(1,5,11,14,15,16,18,20,21)]
shuffle<-setQoL[sample(nrow(setQoL)),]
trainQoL<-shuffle[1:ns,]
testQoL<-shuffle[-c(1:ns),]
dt<-rpart(QoL__4 ~. , data = trainQoL, method="class")
plot(dt, margin = .1, main="Arbre de Régression pour QoL à 12 mois sur VPPBS")
text(dt, use.n = TRUE)
rpart.plot::rpart.plot(dt,type=0, extra=4, main="Arbre de Régression pour QoL à 12 mois sur VPPBS")
summary(dt)
resQoL_VPPBS<-predict(dt, testQoL)
corrplot::corrplot(t(resQoL_VPPBS),is.corr=TRUE, cl.pos = 'n', title="Prédiction QoL pour échantillon de test VPPBS")
##################
setQmax<-subset(rawRTUPBSVPPBS[, c(1:21,36)],"technique"="VPPBS")[,-c(1,5,11,14,15,16,18,20,21)]
shuffle<-setQmax[sample(nrow(setQmax)),]
trainQmax<-shuffle[1:ns,]
testQmax<-shuffle[-c(1:ns),]
dt<-rpart(`Qmax (ml/s)__3` ~. , data = trainQmax)
plot(dt, margin = .1, main="Arbre de Régression pour Qmax à 12 mois sur VPPBS")
text(dt, use.n = TRUE)
summary(dt)
fancyRpartPlot(dt)
resQmax_VPPBS<-predict(dt, testQmax)
barplot( rbind(resQmax_VPPBS, testQmax$`Qmax (ml/s)__3`), beside=TRUE, names.arg = rownames(testQmax), main='Vérification Qmax pour  échantillon de test VPPBS' )
# **********************************
# Classification supervisée VAPOR
# **********************************
library(rpart)
setIPSS<-(rawVAPOR[,c(01:20,34)])[,-c(1,5,11,15)]
# 80% of rows -> training set
ns<-floor(0.80*nrow(setIPSS))
# shuffle rows
shuffle<-setIPSS[sample(nrow(setIPSS)),]
trainIPSS<-shuffle[1:ns,]
testIPSS<-shuffle[-c(1:ns),]
dt<-rpart(IPSS.4 ~. , data = trainIPSS, method="class")
plot(dt, margin = .1, main="Arbre de Régression pour IPSS à 12 mois sur VAPOR")
text(dt, use.n = TRUE)
summary(dt)
rpart.plot::rpart.plot(dt,type=0, extra=4, main="Arbre de Régression pour IPSS à 12 mois sur VAPOR")
summary(dt)
resIPSS_VAPOR<-predict(dt, testIPSS)
corrplot::corrplot(t(resIPSS_VAPOR),is.corr=TRUE, cl.pos = 'n', title="Prédiction IPSS pour échantillon de test VAPOR")
##################
setQoL<-(rawVAPOR[,c(01:20,35)])[,-c(1,5,11,15)]
shuffle<-setQoL[sample(nrow(setQoL)),]
trainQoL<-shuffle[1:ns,]
testQoL<-shuffle[-c(1:ns),]
dt<-rpart(QoL.4 ~. , data = trainQoL, method="class")
plot(dt, margin = .1, main="Arbre de Régression pour QoL à 12 mois sur VAPOR")
text(dt, use.n = TRUE)
rpart.plot::rpart.plot(dt,type=0, extra=4, main="Arbre de Régression pour QoL à 12 mois sur VAPOR")
summary(dt)
resQoL_VAPOR<-predict(dt, testQoL)
corrplot::corrplot(t(resQoL_VAPOR),is.corr=TRUE, cl.pos = 'n', title="Prédiction QoL pour échantillon de test VAPOR")
##################
setQmax<-(rawVAPOR[,c(01:20,36)])[,-c(1,5,11,15)]
shuffle<-setQmax[sample(nrow(setQmax)),]
trainQmax<-shuffle[1:ns,]
testQmax<-shuffle[-c(1:ns),]
dt<-rpart(Qmax..ml.s..3 ~. , data = trainQmax)
plot(dt, margin = .1, main="Arbre de Régression pour Qmax à 12 mois sur VAPOR")
text(dt, use.n = TRUE)
summary(dt)
fancyRpartPlot(dt)
resQmax_VAPOR<-predict(dt, testQmax)
barplot( rbind(resQmax_VAPOR, testQmax$Qmax..ml.s..3), beside=TRUE, names.arg = rownames(testQmax), main='Vérification Qmax pour  échantillon de test VAPOR' )
      
#
# Resultats preOP (au pif pour sortir le diagramme histogramme)
#
rescah_preRTUPB<-hclust(dist(preRTUPB),method="ward")
preRTUPB_class<-cutree(rescah_preRTUPB,12)
rescah_preVPPBS<-hclust(dist(preVPBBS),method="ward")
preVPPBS_class<-cutree(rescah_preVPPBS,12)
#
# Resultats postOP
#
rescah_postRTUPB<-hclust(dist(postRTUPB),method="ward")
postRTUPB_class<-cutree(rescah_postRTUPB,4)
rescah_postVPPBS<-hclust(dist(postVPPBS),method="ward")
postVPPBS_class<-cutree(rescah_postVPPBS,5)
barplot(as.table(rbind(preRTUPB_class,postRTUPB_class)), col=c("darkblue","red"), beside=TRUE, xlab="Patients", ylab="Class ID", names.arg=c(1:32), legend=TRUE, args.legend = list(x = "top"), ylim = c(0,13))
barplot(as.table(rbind(preVPPBS_class,postVPPBS_class)), col=c("darkblue","red"), beside=TRUE, xlab="Patients", ylab="Class ID", names.arg=c(1:32), legend=TRUE, args.legend = list(x = "top"), ylim = c(0,13))



